/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package cn.wps.plugin

import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.internal.artifacts.configurations.DefaultConfiguration
import org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin

/**
 * 动态替换依赖插件，同时为每个project添加一下上传的task，方便上传aar到本地仓库
 */
public class DynamicDependencyPlugin implements Plugin<Project> {
    @Override
    public void apply(Project targetProject) {

        // 这里给每个module添加一个上传的plugin
        targetProject.rootProject.getSubprojects().forEach({
            // 为每一个project添加上传插件
            it.plugins.apply(MavenPublishPlugin)
            // 这一步相当于给每个module添加了一个上传的task，但是该task还没有调用。
            def proj = it
            it.publishing {
                publications {
                    // 这个wps是自定义的字符串
                    wps(MavenPublication) {
                        groupId 'cn.wps'
                        if (proj.name == "base" && proj.path != ":base") {
                            def path = proj.path.replace(":", "-").replaceFirst("-", "")
                            artifactId path
                        } else {
                            artifactId proj.name
                        }
                        version '1.1-SNAPSHOT'

                        def file = new File("${proj.buildDir}/outputs/aar/${proj.name}-cn-debug.aar")
                        // 字符串中有变量引用的时候不能用单引号
                        def file_2 = new File("${proj.buildDir}/outputs/aar/${proj.name}-debug.aar")
                        def final_artifact
                        if (file.exists()) {
                            final_artifact = "${proj.buildDir}/outputs/aar/${proj.name}-cn-debug.aar"
                        } else if (file_2.exists()) {
                            final_artifact = "${proj.buildDir}/outputs/aar/${proj.name}-debug.aar"
                        } else {
                            // 必须要有一个else分支，否则build失败
                            final_artifact = "${proj.buildDir}/libs/${proj.name}.jar"
                        }
                        artifact final_artifact
                    }
                }
                repositories {
                    // 上传到mavenLocal,避免代码泄露
                    mavenLocal()
                }
            }

            // 自定义一个构建并上传aar的task
            def childProject = it
            it.tasks.register("assembleAarAndUploadToMavenLocal") {
                dependsOn("$childProject.path:assemble", "$childProject.path:publishWpsPublicationToMavenLocal")
                group = "build"
                doFirst {
                    println("开始打aar或jar")
                }
                doLast {
                    println("上传完毕")
                }
            }
        })

        // 创建extenstion不能放在afterEvaluate里面，否则找不到 dynamicDependency。但是获取的配置需要在project afterevalute之后
        NamedDomainObjectContainer<DependencyResolveExt> dependencyResolveContainer = targetProject.container(DependencyResolveExt.class)
        targetProject.extensions.add("dynamicDependency", dependencyResolveContainer)

        targetProject.afterEvaluate {
            // 替换逻辑
            targetProject.rootProject.getSubprojects().forEach({
                def childProject = it

                // 判断一下当前工程是不是已经在gradle中申明需要替换的. 如果需要替换则不进行依赖替换.
                def isExist = dependencyResolveContainer.find {
                    childProject.path == it.name
                }

                if (isExist != null) {
                    return
                }

                childProject.afterEvaluate {
                    processRecursive(childProject, dependencyResolveContainer)
                    if (childProject.getSubprojects().size() != 0) {
                        childProject.getSubprojects().forEach({
                            def secondLevelChildProject = it
                            processRecursive(secondLevelChildProject, dependencyResolveContainer)
                            if (secondLevelChildProject.getSubprojects().size() != 0) {
                                secondLevelChildProject.getSubprojects().forEach({
                                    processRecursive(it, dependencyResolveContainer)
                                })
                            }
                        })
                    }
                }
            })
        }

    }

    // 考虑有多层子模块的情况,这里暂时只处理了3层了.
    def processRecursive(Project childProject, NamedDomainObjectContainer<DependencyResolveExt> dependencyResolveContainer) {
        // 这里要加afterEvalute,否则该project的configuration就读不到，size为0.
        childProject.afterEvaluate {
            Map<Project, DependencyResolveExt> resolveExtMap = new HashMap<>()

            childProject.configurations.all { DefaultConfiguration configuration ->
                if (configuration.dependencies.size() == 0) {
                    return
                }

                configuration.dependencies.all { dependency ->
                    if (dependency instanceof DefaultProjectDependency) {
                        def depProjectPath = dependency.dependencyProject.path
                        // 当前依赖项是否在定义的替换dsl中，通过resolveExtMap记录。
                        def dependencyResolveExt = dependencyResolveContainer.find {
                            it.name == depProjectPath
                        }

                        if (dependencyResolveExt != null && childProject.path != depProjectPath) {
                            resolveExtMap.put(dependency.dependencyProject, dependencyResolveExt)
                        }
                    }
                }
            }

            childProject.configurations.all {
                resolutionStrategy {
                    dependencySubstitution {
                        resolveExtMap.each { key, value ->
                            substitute project("${key.path}") with module("${value.groupId}:${getArtifactName(key, value.artifactId)}:${value.version}")
                        }
                    }
                }
            }
        }
    }

    static def getArtifactName(Project project, String name) {
        if (name == null || name == "") {
            return project.name
        }
        return name
    }
}
